/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	 Copyright © 2015 Schneider Electric (Australia) Pty Ltd. All rights reserved. 
//
// 	FILE:	SteelMill_Simulation.ci
//
//	DESCRIPTION:
//
//		Contains functions associated with the SteelMill example. Provides simulation 
//		of SteelMill equipment and configuration for some page components.
//
//	PUBLIC FUNCTIONS:
//
//				
// 	NOTES:
//
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//	MODULE VARIABLES

// Variables to control simulation
// -------------------------------
INT Entry_Accumulator_RampRate;
INT	Entry_MaxLength = 15000;



/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//		FUNCTION NAME	
//						SteelMill_Startup()
//
//		REV	DATE		WHO			DESCRIPTION
//		0	
//
//     	GENERAL DESCRIPTION
//
//			Resets and starts the SteelMill demo simulation. This is called 
//			only once per Citect Runtime start.
//				
// 		ARGUMENTS:
//
//			None
//			
//     	RETURNED VALUE: 
//
//			None
//
//		PSEUDO CODE:
//
// 		Perform Process Analyst Initialization
//		IF Demo NOT Running THEN
//			Reset Demo Data
//		ENDIF
//		Start Sequence task
//		Start Equipment simulation task
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FUNCTION SteelMill_Startup()

	SteelMill_ConfigureAnalyst();
	
END

FUNCTION SteelMill_ServerStartup()

	IF TaskHnd("SteelMill_Sequences") =  -1 THEN
		SteelMill_Reset();
	END

	Sleep(1);
	
	TaskNew("SteelMill_Sequences", "", 4 + 8);
	TaskNew("SteelMill_Equipment", "", 4 + 8);
END



/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//		FUNCTION NAME	
//						SteelMill_Sequences()
//
//		REV	DATE		WHO			DESCRIPTION
//		0	
//
//     	GENERAL DESCRIPTION
//
//			Performs simulation of the SteelMill "Entry" sequence.
//			This is the part of the mill where the raw coils are
//			fed into the system for pressing. The coils are fed in
//			sequentially and welded together. Due to irregularities 
//			in the feed rates, time taken to load and weld, plus varying
//			speeds of downstream processes, the Entry system contains
//			an accumulator to store steel within the process. The
//			accumulator varies in length as required.
//				
// 		ARGUMENTS:
//
//			None
//			
//     	RETURNED VALUE: 
//
//			None
//
//		PSEUDO CODE:
//
// 		WHILE 1 DO
//			Calculate distance Entry travelled	
//			Calculate distance pickler travelled
//			Calculate required accumulator adjustment (difference)
//			Decide on state transition
//			Depending on state, perform relevant action
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FUNCTION SteelMill_Sequences()

INT	Entry_Step0_Progress = 0;
INT	Entry_Step1_Progress = 0;
INT	Entry_Step2_Progress = 0;
INT	Entry_Step3_Progress = 0;
INT	Entry_Step4_Progress = 0;
INT	Entry_Step5_Progress = 0;
INT	Entry_Fault_Progress = 0;
INT	Entry_Counter = 0;

INT	Entry_RemainingDistance = 0;
INT	Entry_CyclesToRampDown = 0;
INT	Entry_DistanceToRampDown = 0;
INT nRandom = 0;

WHILE True DO

//-----------------------------------------------------------------------------
// ACCUMULATION LOGIC
//-----------------------------------------------------------------------------
	IF SimSpeed = 0 THEN SimSpeed = 100; Message("Entry Error", "SimSpeed = 0", 0); END
	Entry_WeldDistance = Entry_WeldDistance + (Entry_Speed/SimSpeed);
	Pickling_WeldDistance = Pickling_WeldDistance + (Pickling_Speed/SimSpeed);
	
	IF (Entry_Accumulator_TempLength + Entry_WeldDistance - Pickling_WeldDistance) >= 0 THEN
		Entry_AccumulatorLength = Entry_Accumulator_TempLength + Entry_WeldDistance - Pickling_WeldDistance;
	ELSE
		Entry_AccumulatorLength = 0;
	END
		

//-----------------------------------------------------------------------------
// SIMULATION VARIABLES
//-----------------------------------------------------------------------------
	Entry_Accumulator_RampRate = 400/SimSpeed;

//-----------------------------------------------------------------------------
// FAULT LOGIC
//-----------------------------------------------------------------------------
	Entry_AccumulatorFull_Fault = Entry_AccumulatorLength >= Entry_MaxLength;
	Entry_Fault = Entry_AccumulatorFull_Fault OR NOT Entry_Equipment_Healthy;


//-----------------------------------------------------------------------------
// ENTRY SEQUENCE LOGIC
// --------------------
//	- Loads new coils into the uncoiling station
//	- Cuts and welds the new coil to the strip in the Entry Accumulator
//	- Uncoils into the Entry Accumulator
//
//	Step 0:	New Coil
//	Step 1:	Changing coils
//	Step 2:	Welding
//	Step 3:	Starting equipment & threading into accumulator
//	Step 4:	Running
//	Step 5: Accumulator Stopping
//-----------------------------------------------------------------------------
	
	IF NOT Entry_Fault THEN
		IF Entry_Step0 AND Entry_Step0_Progress THEN
			Entry_Step0 = 0;
			Entry_Step1 = 1;
			Entry_Counter = 0;
		END

		IF Entry_Step1 AND Entry_Step1_Progress THEN
			Entry_Step1 = 0;
			Entry_Step2 = 1;
			Entry_Counter = 0;
		END

		IF Entry_Step2 AND Entry_Step2_Progress THEN
			Entry_Step2 = 0;
			Entry_Step3 = 1;
			Entry_Counter = 0;
		END

		IF Entry_Step3 AND Entry_Step3_Progress THEN
			Entry_Step3 = 0;
			Entry_Step4 = 1;
			Entry_Counter = 0;
		END

		IF Entry_Step4 AND Entry_Step4_Progress THEN
			Entry_Step4 = 0;
			Entry_Step5 = 1;
			Entry_Counter = 0;
		END

		IF Entry_Step5 AND Entry_Step5_Progress THEN
			Entry_Step5 = 0;
			Entry_Step0 = 1;
			Entry_Counter = 0;
		END
		
		Entry_Step0_Progress = 0;
		Entry_Step1_Progress = 0;
		Entry_Step2_Progress = 0;
		Entry_Step3_Progress = 0;
		Entry_Step4_Progress = 0;
		Entry_Step5_Progress = 0;
		
	END // End of Fault mask

// ----------------
// STEP 0: NEW COIL
// ----------------

	IF Entry_Step0 = 1 THEN
		// STEP 0: ACTIVATION
		Entry_Shear = 0;
		Entry_Welder = 0;
		Entry_Station = 0;		
		Entry_CoilAddition = 0;
		Entry_Accumulator_Clamp = 1;
		Entry_Accumulator = 0;

		IF NOT Entry_Fault AND Entry_Speed > Entry_Accumulator_RampRate THEN
			Entry_Speed = Entry_Speed - Entry_Accumulator_RampRate;
		ELSE
			Entry_Speed = 0;
		END

		// STEP 0 PROGRESS CONDITIONS
		Entry_Counter = Entry_Counter + NOT Entry_Fault;
		IF (Entry_Counter > (Simspeed/5) AND Entry_Speed = 0) THEN
			Entry_Step0_Progress = 1;
		END

	END //End of Step 0

// -----------------------
// STEP 1: COIL CHANGEOVER
// -----------------------

	IF Entry_Step1 = 1 THEN
		// STEP 1: ACTIVATION
		Entry_Shear = 0;
		Entry_Welder = 0;
		Entry_Accumulator_Clamp = 1;
		Entry_Accumulator = 0;
		Entry_CoilAddition = NOT Entry_Fault;
		Entry_Speed = 0;

		IF Entry_Counter > (Simspeed) THEN
			Entry_Station = NOT Entry_Fault;
		END
			
		IF NOT Entry_Fault AND Entry_Counter = 0 THEN

			// GENERATE RANDOM DATA
			IF Entry_CoilID < 32767 THEN
				Entry_CoilID = Entry_CoilID + 1;
			ELSE
				Entry_CoilID = 1;
			END

			nRandom = Rand(4);
			SELECT CASE nRandom 
			CASE 0, 1
				Entry_ProductID = "Thick plate";
			CASE 2
				Entry_ProductID = "Medium plate";
			CASE 3
				Entry_ProductID = "Thin plate";
			CASE ELSE
				Entry_ProductID = "Custom plate";
			END SELECT

			Entry_CoilLength = 750 + Rand(1250);
			Entry_CoilWidth = 1200 + Rand(650);
			Entry_CoilThickness = 3.00 + (IntToReal(Rand(300))/100);
			Entry_SpeedTarget = 200 + Rand(150);
			Entry_Power = 5.00 + (IntToReal(Rand(6000))/1000);

			Entry_CoilWeight = Entry_CoilLength * Entry_CoilWidth * Entry_CoilThickness * 30 / 22200000;

		END

		// STEP 1 PROGRESS CONDITIONS
		Entry_Counter = Entry_Counter + NOT Entry_Fault;
		IF Entry_Counter > (Simspeed) THEN
			Entry_Step1_Progress = 1;
		END

	END //End of Step 1

// ---------------
// STEP 2: WELDING
// ---------------

	IF Entry_Step2 = 1 THEN
		// STEP 2: ACTIVATION
		Entry_CoilAddition = 0;
		Entry_Station = NOT Entry_Fault;
		Entry_Accumulator_Clamp = 1;
		Entry_Accumulator = 0;
		Entry_Speed = 0;

		IF Entry_Counter < (Simspeed/2) THEN
			Entry_Shear = NOT Entry_Fault;
		END
			
		IF Entry_Counter >= (Simspeed/2) THEN
			Entry_Shear = 0;
			Entry_Welder = NOT Entry_Fault;
		END
		
		// STEP 2 PROGRESS CONDITIONS
		Entry_Counter = Entry_Counter + NOT Entry_Fault;
		IF Entry_Counter > (Simspeed) THEN
			Entry_Accumulator_TempLength = Entry_AccumulatorLength;
			Entry_WeldDistance = 0;
			Pickling_WeldDistance = 0;
			Entry_Step2_Progress = 1;
		END

	END //End of Step 2

// ----------------
// STEP 3: STARTING
// ----------------

	IF Entry_Step3 = 1 THEN
		// STEP 3: ACTIVATION
		Entry_CoilAddition = 0;
		Entry_Station = NOT Entry_Fault;
		Entry_Shear = 0;
		Entry_Welder = 0;
		Entry_Accumulator = NOT Entry_Fault AND (Entry_Speed > 0);

		IF Entry_Counter < (Simspeed/3) THEN
			Entry_Accumulator_Clamp = 1;
		END
			
		IF Entry_Counter >= (Simspeed/3) THEN
			Entry_Accumulator_Clamp = Entry_Fault;
		END

		IF NOT Entry_Fault THEN
			IF Entry_Speed < (Entry_SpeedTarget - Entry_Accumulator_RampRate) THEN
				Entry_Speed = Entry_Speed + Entry_Accumulator_RampRate;
			ELSE
				Entry_Speed = Entry_SpeedTarget;
			END
		ELSE
			Entry_Speed = 0;
		END
					
		// STEP 3 PROGRESS CONDITIONS
		Entry_Counter = Entry_Counter + NOT Entry_Fault;
		IF Entry_Counter > (Simspeed*2/3) AND Entry_Speed = Entry_SpeedTarget THEN
			Entry_Step3_Progress = 1;
		END

	END //End of Step 3

// ---------------
// STEP 4: RUNNING
// ---------------

	IF Entry_Accumulator_RampRate = 0 THEN Entry_Accumulator_RampRate = 6; Message("Entry Error", "Entry Accumulator Ramp Rate = 0", 0); END
	Entry_RemainingDistance	= Entry_CoilLength - Entry_WeldDistance;
	Entry_CyclesToRampDown = (Entry_SpeedTarget / Entry_Accumulator_RampRate) + 2;
	IF SimSpeed = 0 THEN SimSpeed = 101; Message("Entry Error", "SimSpeed = 0", 0); END
	Entry_DistanceToRampDown = Entry_CyclesToRampDown * (Entry_SpeedTarget / SimSpeed / 2);			
			
	IF Entry_Step4 = 1 THEN
		// STEP 4: ACTIVATION
		Entry_CoilAddition = 0;
		Entry_Station = NOT Entry_Fault;
		Entry_Shear = 0;
		Entry_Welder = 0;
		Entry_Accumulator_Clamp = Entry_Fault;
		Entry_Accumulator = NOT Entry_Fault;

		IF NOT Entry_Fault THEN
			IF Entry_Speed < (Entry_SpeedTarget - Entry_Accumulator_RampRate) THEN
				Entry_Speed = Entry_Speed + Entry_Accumulator_RampRate;
			ELSE
				IF Entry_Speed > (Entry_SpeedTarget + Entry_Accumulator_RampRate) THEN
					Entry_Speed = Entry_Speed - Entry_Accumulator_RampRate;
				ELSE
					Entry_Speed = Entry_SpeedTarget;
				END
			END
		ELSE
			Entry_Speed = 0;
		END

		// STEP 4 PROGRESS CONDITIONS
		IF NOT Entry_Fault AND (Entry_RemainingDistance <= (Entry_DistanceToRampDown + 15) OR (Entry_AccumulatorLength >= (Entry_MaxLength - Entry_DistanceToRampDown))) THEN
			Entry_Step4_Progress = 1;
		END

	END //End of Step 4
	
// ----------------------------
// STEP 5: STOPPING ACCUMULATOR
// ----------------------------

	IF Entry_Step5 = 1 THEN
		// STEP 5: ACTIVATION
		Entry_CoilAddition = 0;
		Entry_Station = NOT Entry_Fault;
		Entry_Shear = 0;
		Entry_Welder = 0;
		Entry_Accumulator_Clamp = 1;
		Entry_Accumulator = NOT Entry_Fault AND (Entry_Speed > 0);

		IF NOT Entry_Fault AND Entry_Speed > Entry_Accumulator_RampRate THEN
			Entry_Speed = Entry_Speed - Entry_Accumulator_RampRate;
		ELSE
			Entry_Speed = 0;
		END
					
		// STEP 5 PROGRESS CONDITIONS
		IF Entry_Speed = 0 THEN
			Entry_Step5_Progress = 1;
		END

	END //End of Step 5

//-----------------------
// PREVENT OVERRUN ERRORS
//-----------------------
	IF Entry_Counter > 32000 THEN Entry_Counter = 32000; 	Message("Entry Counter", "Counter > 32000", 0); END
	SleepMS(250);

END	//End of "While True" statement
END // End of "Sequences" function




/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//		FUNCTION NAME	
//						SteelMill_Reset()
//
//		REV	DATE		WHO			DESCRIPTION
//		0	
//
//     	GENERAL DESCRIPTION
//
//			Resets all variables and tags used in the SteelMill example.
//			This is run everytime the demo is started (once per Citect run).
//				
// 		ARGUMENTS:
//
//			None
//			
//     	RETURNED VALUE: 
//
//			None
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FUNCTION SteelMill_Reset()

	// Reset to intial state (step 0)
	Entry_Step1 = 0;
	Entry_Step2 = 0;
	Entry_Step3 = 0;
	Entry_Step4 = 0;
	Entry_Step5 = 0;
	Entry_Step0 = 1;

	// Turn equipment off
	Entry_Station = 0;
	Entry_CoilAddition = 0;
	Entry_Shear = 0;
	Entry_Welder = 0;
	Entry_Accumulator_Clamp = 0;
	Entry_Accumulator = 0;

	//Equipment fault tags to be reset
	Entry_Accumulator_Clamp_Fault = 0;
	Entry_Accumulator_Fault = 0;
	Entry_Welder_Fault = 0;
	Entry_Shear_Fault = 0;
	Entry_Station_Fault = 0;
	Entry_CoilAddition_Fault = 0;

	// Reset simulation parameters and current coil information
	IF SimSpeed <= 0 			OR SimSpeed > 500				THEN SimSpeed = 50; END
	IF Entry_CoilID <= 0 		OR Entry_CoilID > 30000			THEN Entry_CoilID = 1; END
	IF Entry_ProductID = "" 									THEN Entry_ProductID = "Thick Plate"; END
	IF Entry_CoilLength = 0 	OR Entry_CoilLength > 2000		THEN Entry_CoilLength = 1500; END
	IF Entry_CoilThickness = 0	OR Entry_CoilThickness > 10 	THEN Entry_CoilThickness = 4.32; END
	IF Entry_CoilWeight = 0 	OR Entry_CoilWeight > 30		THEN Entry_CoilWeight = 25.32; END
	IF Entry_CoilWidth = 0 		OR Entry_CoilWidth > 2000		THEN Entry_CoilWidth = 1255; END
	IF Entry_Power = 0 			OR Entry_Power > 100			THEN Entry_Power = 6.53; END
	IF Entry_SpeedTarget = 0 	OR Entry_SpeedTarget > 1000		THEN Entry_SpeedTarget = 300; END
	IF Pickling_SpeedTarget = 0	OR Pickling_SpeedTarget > 1000	THEN Pickling_SpeedTarget = 200; END

	// Reset simulation variables
	Entry_Speed = 0;
	Pickling_Speed = 0;
	Entry_AccumulatorLength = 7500;
	Entry_Accumulator_TempLength = 7500;
	Entry_WeldDistance = 0;
	Pickling_WeldDistance = 0;
END

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//		FUNCTION NAME	
//						SteelMill_Equipment()
//
//		REV	DATE		WHO			DESCRIPTION
//		0	
//
//     	GENERAL DESCRIPTION
//
//			Simulates faults of the entry equipment and speed of 
//			the Pickling section.
//				
// 		ARGUMENTS:
//
//			None
//			
//     	RETURNED VALUE: 
//
//			None
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FUNCTION SteelMill_Equipment()

// For simulating faults and Pickling speed
REAL	rPicklingSpeed = 0;
INT 	nPicklingFault = 0;
INT 	nEntryFault = 0;
INT 	nRandom = 0;

// Timekeeping variables
INT	SteelMill_MS;
INT	SteelMill_MS_Delta;
INT	SteelMill_Minutes;
INT	SteelMill_TempTime;

SteelMill_TempTime = SysTime();


WHILE True DO

	// Summary of Entry Equipment health
	Entry_Equipment_Healthy = NOT Entry_Accumulator_Clamp_Fault 
									AND NOT Entry_Accumulator_Fault
									AND NOT Entry_Welder_Fault
									AND NOT Entry_Shear_Fault
									AND NOT Entry_Station_Fault
									AND NOT Entry_CoilAddition_Fault;
									
									
	// Accumulation of Time
	SteelMill_MS_Delta = SysTimeDelta(SteelMill_TempTime);
	SteelMill_TempTime = SysTime();


	SteelMill_MS = SteelMill_MS + SteelMill_MS_Delta;
	IF SteelMill_MS >= 60000 THEN
		SteelMill_Minutes = SteelMill_Minutes + 1;
		SteelMill_MS = SteelMill_MS - 60000;
	END

	// Simulate Pickling Equipment Speed
	// Add two basic sinusoid components to a base speed
	rPicklingSpeed = 160 + 25 * Sin(((2 * Pi() * (SteelMill_Minutes * 60 + SteelMill_MS / 1000))) / 1800) +
							25 * Sin(((2 * Pi() * (SteelMill_Minutes * 60 + SteelMill_MS / 1000 + 450))) / 900);

	// Add some noise
	rPicklingSpeed  = rPicklingSpeed  + (Rand(200) / 100.0 - 1)

	// Add some faults
	IF Rand(800) = 10 THEN
		nPicklingFault = 40 + Rand(40);
	END
	
	IF nPicklingFault > 0 THEN
		Pickling_Equipment_Healthy = 0;
		rPicklingSpeed = 0.0;
		nPicklingFault = nPicklingFault - 1;
	ELSE
		Pickling_Equipment_Healthy = 1;
	END

	// Assign speed to the tag
	Pickling_Speed = rPicklingSpeed;

	// Simulate Faults - nEntry fault controls how long the 
	// fault will last. When there is no fault, a random number
	// decides if a fault is to be started and then how long
	// it will go for. Multidigital alarm states are also set as
	// the fault is simulated.
	IF nEntryFault = 0 THEN
	
		nEntryFault = 40 + Rand(40);
		nRandom = Rand(2000);
		SELECT CASE nRandom 
		CASE 21
			// Clamp Fault
			Entry_Accumulator_Clamp_Fault = 1;
			Entry_Fault_State2 = 0;
			Entry_Fault_State1 = 0;
			Entry_Fault_State0 = 1;
		CASE 31
			// Accumulator Fault
			Entry_Accumulator_Fault = 1;
			Entry_Fault_State2 = 0;
			Entry_Fault_State1 = 1;
			Entry_Fault_State0 = 0;
		CASE 41
			// Welder Fault
			Entry_Welder_Fault = 1;
			Entry_Fault_State2 = 0;
			Entry_Fault_State1 = 1;
			Entry_Fault_State0 = 1;
		CASE 51
			// Shear Fault
			Entry_Shear_Fault = 1;
			Entry_Fault_State2 = 1;
			Entry_Fault_State1 = 0;
			Entry_Fault_State0 = 0;
		CASE 61
			// Station Fault
			Entry_Station_Fault = 1;
			Entry_Fault_State2 = 1;
			Entry_Fault_State1 = 0;
			Entry_Fault_State0 = 1;
		CASE 71
			// Coil Add Fault
			Entry_CoilAddition_Fault = 1;
			Entry_Fault_State2 = 1;
			Entry_Fault_State1 = 1;
			Entry_Fault_State0 = 0;
		CASE ELSE
			// No fault - reset states
			nEntryFault = 0;
			Entry_Fault_State2 = 0;
			Entry_Fault_State1 = 0;
			Entry_Fault_State0 = 0;
			Entry_Accumulator_Clamp_Fault = 0;
			Entry_Accumulator_Fault = 0;
			Entry_Welder_Fault = 0;
			Entry_Shear_Fault = 0;
			Entry_Station_Fault = 0;
			Entry_CoilAddition_Fault = 0;
		END SELECT
		
	ELSE
		// Fault is currently occuring, simply deduct from its timer
		nEntryFault = nEntryFault - 1;
	END
	
	SleepMS(250);
	
END // End of While TRUE

END


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//		FUNCTION NAME	
//						SteelMill_ConfigureAnalyst()
//
//		REV	DATE		WHO			DESCRIPTION
//		0	
//
//     	GENERAL DESCRIPTION
//
//			Confugres the embedded Process Analyst for the 
//			SteelMill page.
//				
// 		ARGUMENTS:
//
//			None
//			
//     	RETURNED VALUE: 
//
//			None
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FUNCTION SteelMill_ConfigureAnalyst()

	ErrSet(0);
	
	// Resolve STEELMILL Analyst and load the SteelMill PAV
	OBJECT hAnalyst		= ObjectByName("STEELMILL_PA");
	_ObjectCallMethod(hAnalyst, "LoadFromFile", "SteelMillInsert.pav", 0);
	
	// Resolve other require Analyst Objects
	OBJECT hToolbars	= _ObjectGetProperty(hAnalyst, "Toolbars");
	OBJECT hMainToolbar	= _ObjectCallMethod(hToolbars, "get_Item", 1);
	OBJECT hPanes		= _ObjectGetProperty(hAnalyst, "Panes");
	OBJECT hPane1 		= _ObjectCallMethod(hPanes, "get_Item", 1);
	OBJECT hPens		= _ObjectGetProperty(hPane1, "Pens");
	OBJECT hPen1		= _ObjectCallMethod(hPens, "get_Item", 1);
	
	// Make the Main Toolbar invisible
	_ObjectSetProperty(hMainToolbar, "Visible", 0);
	
	// Scroll the chart over to meet up with the cursor and
	// select the first pen
	_ObjectCallMethod(hPen1, "HorizontalScrollBy", -0.3);
	_ObjectCallMethod(hPen1, "Select");
	
	IsError();
	ErrSet(1);
END
	





